package main

import (
	"bytes"
	"compress/zlib"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/signal"
	"time"

	"github.com/genshinsim/gcsim/backend/pkg/services/share"
	"github.com/genshinsim/gcsim/pkg/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type entry struct {
	Key        string    `json:"simulation_key" bson:"_id"`
	Metadata   string    `json:"metadata" bson:"metadata"`
	Viewer     string    `json:"viewer_file" bson:"viewer_file"`
	Permanent  bool      `json:"is_permanent" bson:"is_permanent"`
	CreateTime time.Time `json:"create_time" bson:"create_time"`
}

func (e entry) toAuto() (*AutoGenerated, error) {
	//base64 zlib encoded string
	z, err := base64.StdEncoding.DecodeString(e.Viewer)
	if err != nil {
		return nil, err
	}

	//decompress
	reader, err := zlib.NewReader(bytes.NewReader(z))
	if err != nil {
		return nil, err
	}
	b, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}

	var target AutoGenerated
	err = json.Unmarshal(b, &target)
	return &target, err
}

type AutoGenerated struct {
	V2              bool        `json:"v2"`
	Version         string      `json:"version"`
	BuildDate       string      `json:"build_date"`
	IsDamageMode    bool        `json:"is_damage_mode"`
	ActiveChar      string      `json:"active_char"`
	CharNames       []string    `json:"char_names"`
	RequiredEr      interface{} `json:"required_er"`
	IncompleteChars interface{} `json:"incomplete_chars"`
	SimDuration     struct {
		Min  float64 `json:"min"`
		Max  float64 `json:"max"`
		Mean float64 `json:"mean"`
		Sd   float64 `json:"sd"`
	} `json:"sim_duration"`
	Damage struct {
		Min  float64 `json:"min"`
		Max  float64 `json:"max"`
		Mean float64 `json:"mean"`
		Sd   float64 `json:"sd"`
	} `json:"damage"`
	Dps struct {
		Min  float64 `json:"min"`
		Max  float64 `json:"max"`
		Mean float64 `json:"mean"`
		Sd   float64 `json:"sd"`
	} `json:"dps"`
	// DpsByTarget []struct {
	// 	Min  float64 `json:"min"`
	// 	Max  float64 `json:"max"`
	// 	Mean float64 `json:"mean"`
	// 	Sd   float64 `json:"sd"`
	// } `json:"dps_by_target"`
	Iter        int     `json:"iter"`
	Runtime     float64 `json:"runtime"`
	NumTargets  int     `json:"num_targets"`
	CharDetails []struct {
		Name     string `json:"name"`
		Element  string `json:"element"`
		Level    int    `json:"level"`
		MaxLevel int    `json:"max_level"`
		Cons     int    `json:"cons"`
		Weapon   struct {
			Name     string `json:"name"`
			Refine   int    `json:"refine"`
			Level    int    `json:"level"`
			MaxLevel int    `json:"max_level"`
		} `json:"weapon"`
		Talents struct {
			Attack int `json:"attack"`
			Skill  int `json:"skill"`
			Burst  int `json:"burst"`
		} `json:"talents"`
		Sets     map[string]int `json:"sets"`
		Stats    []float64      `json:"stats"`
		Snapshot []float64      `json:"snapshot"`
	} `json:"char_details"`
	TargetDetails []struct {
		Level int `json:"level"`
	} `json:"target_details"`
	ConfigFile string `json:"config_file"`
	Text       string `json:"text"`
}

func (a AutoGenerated) toPB() *share.ShareEntry {
	var stamp time.Time
	var err error
	if a.BuildDate != "" {
		stamp, err = time.Parse(time.RFC3339, a.BuildDate)
		if err != nil {
			fmt.Printf("WARNING: failed to decode build time %v; setting time 0\n", a.BuildDate)
		}
	}
	r := &model.SimulationResult{
		SchemaVersion: &model.Version{
			Major: "0",
			Minor: "0",
		},
		SimVersion: &a.Version,
		BuildDate:  stamp.Format(time.RFC3339),
		Config:     a.ConfigFile,
		SimulatorSettings: &model.SimulatorSettings{
			Iterations: uint32(a.Iter),
		},
		InitialCharacter: a.ActiveChar,
		// Statistics: &model.SimulationStatistics{
		// 	Iterations: uint32(a.Iter),
		// 	Duration: &model.OverviewStats{
		// 		Min:  &a.SimDuration.Min,
		// 		Max:  &a.SimDuration.Max,
		// 		Mean: &a.SimDuration.Mean,
		// 		SD:   &a.SimDuration.Sd,
		// 	},
		// 	DPS: &model.OverviewStats{
		// 		Min:  &a.Dps.Min,
		// 		Max:  &a.Dps.Max,
		// 		Mean: &a.Dps.Mean,
		// 		SD:   &a.Dps.Sd,
		// 	},
		// 	TotalDamage: &model.DescriptiveStats{
		// 		Min:  &a.Damage.Min,
		// 		Max:  &a.Damage.Max,
		// 		Mean: &a.Damage.Mean,
		// 		SD:   &a.Damage.Sd,
		// 	},
		// },
	}
	if a.IsDamageMode {
		r.Mode = model.SimMode_TTK_MODE
	} else {
		r.Mode = model.SimMode_DURATION_MODE
	}
	for _, c := range a.CharDetails {
		m := &model.Character{
			Name:     c.Name,
			Element:  c.Element,
			Level:    int32(c.Level),
			MaxLevel: int32(c.MaxLevel),
			Cons:     int32(c.Cons),
			Weapon: &model.Weapon{
				Name:     c.Weapon.Name,
				Refine:   int32(c.Weapon.Refine),
				Level:    int32(c.Weapon.Level),
				MaxLevel: int32(c.Weapon.MaxLevel),
			},
			Talents: &model.CharacterTalents{
				Attack: int32(c.Talents.Attack),
				Skill:  int32(c.Talents.Skill),
				Burst:  int32(c.Talents.Burst),
			},
			Sets: make(map[string]int32),
		}
		for k, count := range c.Sets {
			m.Sets[k] = int32(count)
		}
		m.Stats = append(m.Stats, c.Stats...)
		m.SnapshotStats = append(m.SnapshotStats, c.Snapshot...)
		r.CharacterDetails = append(r.CharacterDetails, m)
	}
	for _, e := range a.TargetDetails {
		m := &model.Enemy{
			Level: int32(e.Level),
		}
		r.TargetDetails = append(r.TargetDetails, m)
	}
	//FORCE ID
	e := &share.ShareEntry{
		Result:    r,
		ExpiresAt: uint64(time.Now().Unix() + 60*60*24*365),
	}
	return e
}

const (
	exitCodeErr       = 1
	exitCodeInterrupt = 2
)

func main() {
	clientOld, err := mongoConnect("mongodb://192.168.100.102:2700")
	if err != nil {
		panic(err)
	}
	clientNext, err := mongoConnect("mongodb://192.168.100.102:27017")
	if err != nil {
		panic(err)
	}
	colOld := clientOld.Database("store").Collection("data")
	colNext := clientNext.Database("gcsim-database").Collection("shares")

	ctx := context.Background()
	ctx, cancel := context.WithCancel(ctx)
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt)
	defer func() {
		signal.Stop(signalChan)
		cancel()
	}()
	go func() {
		select {
		case <-signalChan: // first signal, cancel context
			cancel()
		case <-ctx.Done():
		}
		<-signalChan // second signal, hard exit
		os.Exit(exitCodeInterrupt)
	}()
	if err := run(ctx, colOld, colNext); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(exitCodeErr)
	}

}

const limit = 50
const max = 200

func run(ctx context.Context, colOld, colNext *mongo.Collection) error {
	//find last inserted
	last, err := mongoFindLatestEntry(colNext)
	if err != nil {
		return err
	}
	// last = nil
	lastTime := time.Unix(0, 0)
	lastKey := ""
	if last == nil {
		log.Println("no entries found in new db")
	}

	count := 0
	for {
		if last != nil {
			log.Printf("last entry: %v - %v\n", last.Id, last.Result.CreatedDate)
			lastTime = time.Unix(last.Result.CreatedDate, 0)
			lastKey = last.Id
		}
		select {
		case <-ctx.Done():
			log.Println("interrupt signal received")
			return nil
		default:
			if count >= max {
				log.Println("limit reached")
				return nil
			}

			data, err := mongoFindOlderThan(context.TODO(), colOld, lastTime)
			if err != nil {
				return err
			}
			for i, v := range data {
				if v.Key == lastKey {
					log.Println("skipping last: ", v.Key)
					continue
				}
				log.Println(v.Key, v.CreateTime)
				a, err := v.toAuto()
				if err != nil {
					fmt.Printf("WARNING: failed to decode share with key %v: %v", v.Key, err)
					continue
				}
				next := a.toPB()
				next.Id = v.Key
				next.Result.CreatedDate = v.CreateTime.Unix()
				err = mongoInsert(ctx, colNext, next)
				if err != nil {
					fmt.Printf("WARNING: failed to insert share with key %v: %v", v.Key, err)
					continue
				}
				if i == len(data)-1 {
					last = next
				}
			}
			count += len(data)
			log.Printf("inserted %v, count is now %v\n", len(data), count)
		}

	}
	// a, err := last.toAuto()
	// if err != nil {
	// 	return err
	// }
	// next := a.toPB()
	// next.Id = last.Key
	// err = mongoInsert(ctx, colNext, next)
	// if err != nil {
	// 	return err
	// }
	// return nil
}

func mongoConnect(addr string) (*mongo.Client, error) {
	credential := options.Credential{
		Username: "root",
		Password: "root-password",
	}

	client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(addr).SetAuth(credential))
	if err != nil {
		return nil, err
	}

	//check connection
	err = client.Ping(context.TODO(), nil)

	if err != nil {
		log.Println("ping failed", err)
		return nil, err
	}
	return client, nil
}

func mongoInsert(ctx context.Context, col *mongo.Collection, d interface{}) error {
	res, err := col.InsertOne(ctx, d)
	if err != nil {
		return err
	}
	log.Println("inserted with id: ", res.InsertedID)
	return nil
}

func mongoFindLatestEntry(col *mongo.Collection) (*share.ShareEntry, error) {
	result := &share.ShareEntry{}
	res := col.FindOne(context.TODO(),
		bson.M{
			"result.schema_version.major": "0",
		},
		&options.FindOneOptions{
			Sort: bson.M{
				"result.created_date": -1,
			},
		})
	err := res.Err()
	if err == mongo.ErrNoDocuments {
		return nil, nil
	}
	if err != nil {
		return result, err
	}
	err = res.Decode(&result)
	if err != nil {
		log.Println("error decoding")
		return result, err
	}
	return result, nil
}

func mongoFindOlderThan(ctx context.Context, col *mongo.Collection, stamp time.Time) ([]entry, error) {
	var result []entry
	var l int64 = limit
	cursor, err := col.Find(
		ctx,
		bson.M{
			"create_time": bson.M{
				"$gte": stamp,
			},
		},
		&options.FindOptions{
			Sort: bson.M{
				"create_time": 1,
			},
			Limit: &l,
		},
	)
	if err != nil {
		return nil, err
	}
	for cursor.Next(ctx) {
		var r entry
		if err := cursor.Decode(&r); err != nil {
			log.Println("error reading cursor: ", err)
			return nil, err
		}
		result = append(result, r)
	}
	return result, nil
}
