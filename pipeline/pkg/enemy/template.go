package enemy

import (
	"fmt"
	"html/template"
	"os"
	"path/filepath"
)

func (g *Generator) GenerateEnemyStats(path string) error {
	fdata, err := os.Create(filepath.Join(path, "model", "enemy.go"))
	if err != nil {
		return err
	}

	t, err := template.New("enemycurves").Parse(tmplEnemyStats)
	if err != nil {
		return fmt.Errorf("failed to build template: %w", err)
	}
	return t.Execute(fdata, g.data)
}

func (g *Generator) GenerateEnemyShortcuts(path string) error {
	fdata, err := os.Create(filepath.Join(path, "shortcut", "enemies.go"))
	if err != nil {
		return err
	}

	t, err := template.New("enemyshortcuts").Parse(tmplShortcuts)
	if err != nil {
		return fmt.Errorf("failed to build template: %w", err)
	}
	return t.Execute(fdata, g.data)
}

const tmplEnemyStats = `// Code generated by "pipeline"; DO NOT EDIT.
package model

var EnemyMap = map[int]*MonsterData{
{{- range .}}
	{{.Id}}: {
		Id: {{.Id}},
		Key: "{{.Key}}",
		NameTextHashMap: {{.NameTextHashMap}},
		BaseStats: &MonsterStatsData{
			BaseHp:  {{.BaseStats.BaseHp}},
			HpCurve: MonsterCurveType_{{.BaseStats.HpCurve}},
			Resist: &MonsterResistData{
				FireResist:     {{.BaseStats.Resist.FireResist}},
				GrassResist:    {{.BaseStats.Resist.GrassResist}},
				WaterResist:    {{.BaseStats.Resist.WaterResist}},
				ElectricResist: {{.BaseStats.Resist.ElectricResist}},
				WindResist:     {{.BaseStats.Resist.WindResist}},
				IceResist:      {{.BaseStats.Resist.IceResist}},
				RockResist:     {{.BaseStats.Resist.RockResist}},
				PhysicalResist: {{.BaseStats.Resist.PhysicalResist}},
			},
			FreezeResist: {{.BaseStats.FreezeResist}},
			HpDrop: []*MonsterHPDrop{
				{{- range .BaseStats.HpDrop}}
				{
					DropId:    {{.DropId}},
					HpPercent: {{.HpPercent}},
				},
				{{- end}}
			},
		},
	},
{{- end}}
}

`

var tmplShortcuts = `package shortcut

var MonsterNameToID = map[string]int{
{{- range $key, $value := .}}
	"{{$value.Key}}": {{$value.Id}},
{{- end}}
}
`
